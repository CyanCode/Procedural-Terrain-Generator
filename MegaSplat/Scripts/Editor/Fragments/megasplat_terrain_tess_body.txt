
            float4 _SplatControl_TexelSize;

            struct VertexInput 
            {
                float4 vertex        : POSITION;
                float3 normal        : NORMAL;
                float2 texcoord0     : TEXCOORD0;

                float2 texcoord1 : TEXCOORD1;
                float2 texcoord2 : TEXCOORD2;

            };
             
            VirtualMapping GetMapping(VertexOutput i, sampler2D splatControl, sampler2D paramControl)
            {
               float2 texSize = _SplatControl_TexelSize.zw;
               float2 stp = _SplatControl_TexelSize.xy;
               // scale coords so we can take floor/frac to construct a cell
               float2 stepped = i.coords.xy * texSize;
               float2 uvBottom = floor(stepped);
               float2 uvFrac = frac(stepped);
               uvBottom /= texSize;

               float2 center = stp * 0.5;
               uvBottom += center;

               // construct uv/positions of triangle based on our interpolation point
               float2 cuv0, cuv1, cuv2;
               // make virtual triangle
               if (uvFrac.x > uvFrac.y)
               {
                  cuv0 = uvBottom;
                  cuv1 = uvBottom + float2(stp.x, 0);
                  cuv2 = uvBottom + float2(stp.x, stp.y);
               }
               else
               {
                  cuv0 = uvBottom;
                  cuv1 = uvBottom + float2(0, stp.y);
                  cuv2 = uvBottom + float2(stp.x, stp.y);
               }

               float2 uvBaryFrac = uvFrac * stp + uvBottom;
               float3 weights = Barycentric(uvBaryFrac, cuv0, cuv1, cuv2);
               VirtualMapping m = (VirtualMapping)0;
               m.weights = weights;
               m.c0 = tex2Dlod(splatControl, float4(cuv0, 0, 0));
               m.c1 = tex2Dlod(splatControl, float4(cuv1, 0, 0));
               m.c2 = tex2Dlod(splatControl, float4(cuv2, 0, 0));

               #if _PUDDLES || _PUDDLEFLOW || _PUDDLEREFRACT || _WETNESS || _FLOW || _FLOWREFRACTION || _LAVA
               fixed4 p0 = tex2Dlod(paramControl, float4(cuv0, 0, 0));
               fixed4 p1 = tex2Dlod(paramControl, float4(cuv1, 0, 0));
               fixed4 p2 = tex2Dlod(paramControl, float4(cuv2, 0, 0));
               m.param = p0 * weights.x + p1 * weights.y + p2 * weights.z;
               #endif
               return m;
            }

            SplatInput ToSplatInput(VertexOutput i, VirtualMapping m)
            {
               SplatInput o = (SplatInput)0;
               UNITY_INITIALIZE_OUTPUT(SplatInput,o);

               o.camDist = i.camDist;
               o.splatUV = i.coords;
               o.macroUV = i.coords;
               #if _SECONDUV
               o.macroUV = i.macroUV;
               #endif
               o.weights = m.weights;


               o.valuesMain = float3(m.c0.r, m.c1.r, m.c2.r);
               #if _TWOLAYER || _ALPHALAYER
               o.valuesSecond = float3(m.c0.g, m.c1.g, m.c2.g);
               o.layerBlend = m.c0.b * o.weights.x + m.c1.b * o.weights.y + m.c2.b * o.weights.z;
               #endif

               #if _TRIPLANAR
               o.triplanarUVW = i.triplanarUVW;
               o.triplanarBlend = i.extraData.xyz;
               #endif

               #if _FLOW || _FLOWREFRACTION || _PUDDLEFLOW || _PUDDLEREFRACT || _LAVA
               o.flowDir = m.param.xy;
               #endif

               #if _PUDDLES || _PUDDLEFLOW || _PUDDLEREFRACT || _LAVA
               o.puddleHeight = m.param.a;
               #endif

               #if _WETNESS
               o.wetness = m.param.b;
               #endif

               #if _GEOMAP
               o.worldPos = i.posWorld;
               #endif

               return o;
            }

            LayerParams GetMainParams(VertexOutput i, inout VirtualMapping m, half2 texScale)
            {
               
               int i0 = (int)(m.c0.r * 255);
               int i1 = (int)(m.c1.r * 255);
               int i2 = (int)(m.c2.r * 255);

               LayerParams data = NewLayerParams();

               float2 splatUV = i.coords.xy * texScale.xy;
               data.uv0 = float3(splatUV, i0);
               data.uv1 = float3(splatUV, i1);
               data.uv2 = float3(splatUV, i2);


               #if _TRIPLANAR
               float3 coords = i.triplanarUVW.xyz * texScale.x;
               data.tpuv0_x = float3(coords.zy, i0);
               data.tpuv0_y = float3(coords.xz, i0);
               data.tpuv0_z = float3(coords.xy, i0);
               data.tpuv1_x = float3(coords.zy, i1);
               data.tpuv1_y = float3(coords.xz, i1);
               data.tpuv1_z = float3(coords.xy, i1);
               data.tpuv2_x = float3(coords.zy, i2);
               data.tpuv2_y = float3(coords.xz, i2);
               data.tpuv2_z = float3(coords.xy, i2);
               #endif

               data.layerBlend = m.weights.x * m.c0.b + m.weights.y * m.c1.b + m.weights.z * m.c2.b;

               #if _FLOW || _FLOWREFRACTION
               data.flowOn = 0;
               #endif

               return data;
            }

            LayerParams GetSecondParams(VertexOutput i, VirtualMapping m, half2 texScale)
            {
               int i0 = (int)(m.c0.g * 255);
               int i1 = (int)(m.c1.g * 255);
               int i2 = (int)(m.c2.g * 255);

               LayerParams data = NewLayerParams();

               float2 splatUV = i.coords.xy * texScale.xy;
               data.uv0 = float3(splatUV, i0);
               data.uv1 = float3(splatUV, i1);
               data.uv2 = float3(splatUV, i2);


               #if _TRIPLANAR
               float3 coords = i.triplanarUVW.xyz * texScale.x;
               data.tpuv0_x = float3(coords.zy, i0);
               data.tpuv0_y = float3(coords.xz, i0);
               data.tpuv0_z = float3(coords.xy, i0);
               data.tpuv1_x = float3(coords.zy, i1);
               data.tpuv1_y = float3(coords.xz, i1);
               data.tpuv1_z = float3(coords.xy, i1);
               data.tpuv2_x = float3(coords.zy, i2);
               data.tpuv2_y = float3(coords.xz, i2);
               data.tpuv2_z = float3(coords.xy, i2);
               #endif

               #if _FLOW || _FLOWREFRACTION
               data.flowOn = 0;
               #endif

               return data;   
            }


            VertexOutput NoTessVert(VertexInput v)
            {
               VertexOutput o = (VertexOutput)0;

               o.tangent.xyz = cross(v.normal, float3(0,0,1));
               float4 tangent = float4(o.tangent, 1);
               {
                  #if _CUSTOMUSERFUNCTION
                  float4 tangent = float4(o.tangent, 1);
                  CustomMegaSplatFunction_PreVertex(v.vertex, v.normal, tangent, v.texcoord0.xy);
                  o.tangent = tangent.xyz;
                  #endif
               }

               {
                  #if _USECURVEDWORLD
                  float4 tangent = float4(o.tangent, 1);
                  V_CW_TransformPointAndNormal(v.vertex, v.normal, tangent);
                  o.tangent = tangent.xyz;
                  #endif
               }

               UNITY_INITIALIZE_OUTPUT(VertexOutput,o);

               o.normal = UnityObjectToWorldNormal(v.normal);
               o.pos = UnityObjectToClipPos(v.vertex);
               o.posWorld = mul(unity_ObjectToWorld, v.vertex).xyz;

               o.coords.xy = v.texcoord0;
               #if _SECONDUV
               o.macroUV.xy = v.texcoord0;
               o.macroUV = ProjectUV2(v.vertex, o.macroUV.xy, o.posWorld, o.normal, tangent);
               #endif

               o.coords.xy = ProjectUVs(v.vertex, o.coords.xy, o.posWorld, o.normal, tangent);


               #if !_PASSSHADOWCASTER && !_PASSMETA
               o.ambientOrLightmapUV = VertexGIForward(v.texcoord1.xy, v.texcoord2.xy, o.posWorld, o.normal);
               #endif

               float dist = distance(_WorldSpaceCameraPos, mul(unity_ObjectToWorld, v.vertex));
               o.camDist.x = 1.0 - saturate((dist - _DistanceFades.x) / (_DistanceFades.y - _DistanceFades.x));
               float3 viewSpace = UnityObjectToViewPos(v.vertex);
               o.camDist.y = length(viewSpace.xyz);
               #if _TRIPLANAR
                  float3 norm = v.normal;
                  #if _TRIPLANAR_WORLDSPACE
                  o.triplanarUVW.xyz = o.posWorld.xyz * _TriplanarTexScale + _TriplanarOffset;
                  norm = normalize(mul((float3x3)unity_ObjectToWorld, norm));
                  #else
                  o.triplanarUVW.xyz = v.vertex.xyz * _TriplanarTexScale + _TriplanarOffset;
                  #endif
                  o.extraData.xyz = pow(abs(norm), _TriplanarContrast);
                  o.extraData.xyz /= dot(o.extraData.xyz, float3(1,1,1));

                  half3 normal  = UnityObjectToWorldNormal(norm);
                  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                  float3 sgn = sign(normal);
                  half3 tnorm = max(pow(abs(normal), 10), 0.0001);
                  tnorm /= dot(tnorm, half3(1,1,1));

                  o.tangent.xyz = cross(o.normal, mul(unity_WorldToObject, fixed4(0, sgn.x, 0, 0)).xyz * tnorm.x)
                          + cross(o.normal, mul(unity_WorldToObject, fixed4(0, 0, sgn.y, 0)).xyz * tnorm.y)
                          + cross(o.normal, mul(unity_WorldToObject, fixed4(0, sgn.z, 0, 0)).xyz * tnorm.z);
                  o.tangent.w = -1;
               #endif


               o.bitangent = normalize(cross(o.normal, o.tangent) * -1);  
               

               UNITY_TRANSFER_SHADOW(o,v.texcoord1.xy); // pass shadow coordinates to pixel shader
               UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  
               return o;
            }


            #if _TESSDISTANCE || _TESSEDGE
            VertexOutput NoTessShadowVertBiased(VertexInput v)
            {
               VertexOutput o = (VertexOutput)0;
               {
                  #if _CUSTOMUSERFUNCTION
                  float4 tangent = float4(0,0,0,0);
                  CustomMegaSplatFunction_PreVertex(v.vertex, v.normal, tangent, v.texcoord0.xy);
                  #endif
               }
               {
                  #if _USECURVEDWORLD
                  float4 tangent = float4(0,0,0,0);
                  V_CW_TransformPointAndNormal(v.vertex, v.normal, tangent);
                  #endif
                  UNITY_INITIALIZE_OUTPUT(VertexOutput,o);
               }
             
               o.normal = UnityObjectToWorldNormal(v.normal);
               v.vertex.xyz -= o.normal * _TessData1.yyy * half3(0.5, 0.5, 0.5);
               o.pos = UnityObjectToClipPos(v.vertex);
               o.coords = v.texcoord0;

               #if _PASSSHADOWCASTER
               TRANSFER_SHADOW_CASTER(o)
               #endif

               return o;
            }
            #endif

            #ifdef UNITY_CAN_COMPILE_TESSELLATION
            #if _TESSDISTANCE || _TESSEDGE 
            struct TessVertex 
            {
                 float4 pos       : INTERNALTESSPOS;
                 float3 normal       : NORMAL;
                 float2 coords       : TEXCOORD0;      // uv, or triplanar UV
                 #if _TRIPLANAR
                 float3 triplanarUVW : TEXCOORD1;
                 float4 extraData    : TEXCOORD2;
                 #endif
                 float4 camDist      : TEXCOORD3;      // distance from camera (for fades) and fog

                 float3 posWorld     : TEXCOORD4;
                 float4 tangent      : TEXCOORD5;
                 float2 macroUV      : TEXCOORD6;
                 UNITY_SHADOW_COORDS(7)
                 UNITY_FOG_COORDS(8)
                 float2 texcoord1    : TEXCOORD10;

                 float4 ambientOrLightmapUV : TEXCOORD9;

 
             };


            VertexOutput vert (TessVertex v) 
            {
                VertexOutput o = (VertexOutput)0;

                UNITY_INITIALIZE_OUTPUT(VertexOutput,o);

                #if _CUSTOMUSERFUNCTION
                CustomMegaSplatFunction_PreVertex(v.pos, v.normal, v.tangent, v.coords.xy);
                #endif
                #if _USECURVEDWORLD
                V_CW_TransformPointAndNormal(v.pos, v.normal, v.tangent);
                #endif

                o.ambientOrLightmapUV = v.ambientOrLightmapUV;

                o.normal = UnityObjectToWorldNormal(v.normal);
                o.tangent = normalize( mul( unity_ObjectToWorld, float4( v.tangent.xyz, 0.0 ) ).xyz );
                o.bitangent = normalize(cross(o.normal, o.tangent) * v.tangent.w);  

                #if _PASSSHADOWCASTER
                o.pos = UnityClipSpaceShadowCasterPos(v.pos, v.normal);
                o.pos = UnityApplyLinearShadowBias(o.pos);
                #else
                o.pos = UnityObjectToClipPos(v.pos);
                #endif
                o.coords = v.coords;
                o.camDist = v.camDist;
                o.posWorld = v.posWorld;
                #if _SECONDUV
                o.macroUV = v.macroUV;
                #endif

                #if _TRIPLANAR
                o.triplanarUVW = v.triplanarUVW;
                o.extraData = v.extraData;
                #endif

                #if defined(SHADOWS_ENABLED)
                o._ShadowCoord = v._ShadowCoord;
                #endif
                UNITY_TRANSFER_SHADOW(o,v.texcoord1.xy); // pass shadow coordinates to pixel shader
                UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  

                return o;
            }


                
             struct OutputPatchConstant {
                 float edge[3]         : SV_TessFactor;
                 float inside          : SV_InsideTessFactor;
                 float3 vTangent[4]    : TANGENT;
                 float2 vUV[4]         : TEXCOORD;
                 float3 vTanUCorner[4] : TANUCORNER;
                 float3 vTanVCorner[4] : TANVCORNER;
                 float4 vCWts          : TANWEIGHTS;
             };

             TessVertex tessvert (VertexInput v) 
             {
                 TessVertex o;
                 UNITY_INITIALIZE_OUTPUT(TessVertex,o);
                 #if _USECURVEDWORLD
                 V_CW_TransformPointAndNormal(v.vertex, v.normal, v.tangent);
                 #endif

                 o.pos = v.vertex;
                 o.normal = v.normal;
                 o.coords.xy = v.texcoord0;
                 o.normal = UnityObjectToWorldNormal(v.normal);
                 o.posWorld = mul(unity_ObjectToWorld, v.vertex).xyz;

                 float4 tangent = float4(o.tangent.xyz, 1);
                 #if _SECONDUV
                 o.macroUV = v.texcoord0;
                 o.macroUV = ProjectUV2(v.vertex, o.macroUV.xy, o.posWorld, o.normal, tangent);
                 #endif

                 o.coords.xy = ProjectUVs(v.vertex, o.coords.xy, o.posWorld, o.normal, tangent);



                 #if !_PASSSHADOWCASTER && !_PASSMETA
                 o.ambientOrLightmapUV = VertexGIForward(v.texcoord1.xy, v.texcoord2.xy, o.posWorld, o.normal);
                 #endif

                 float dist = distance(_WorldSpaceCameraPos, mul(unity_ObjectToWorld, v.vertex));
                 o.camDist.x = 1.0 - saturate((dist - _DistanceFades.x) / (_DistanceFades.y - _DistanceFades.x));
                 float3 viewSpace = UnityObjectToViewPos(v.vertex);
                 o.camDist.y = length(viewSpace.xyz);
                 #if _TRIPLANAR
                    #if _TRIPLANAR_WORLDSPACE
                    o.triplanarUVW.xyz = o.posWorld.xyz * _TriplanarTexScale + _TriplanarOffset;
                    #else
                    o.triplanarUVW.xyz = v.vertex.xyz * _TriplanarTexScale + _TriplanarOffset;
                    #endif
                    o.extraData.xyz = pow(abs(v.normal), _TriplanarContrast);
                    o.extraData.xyz /= dot(o.extraData.xyz, float3(1,1,1));
                 #endif

                 o.tangent.xyz = cross(v.normal, float3(0,0,1));
                 o.tangent.w = -1;

                 float tessFade = saturate((dist - _TessData2.x) / (_TessData2.y - _TessData2.x));
                 tessFade *= tessFade;
                 o.camDist.w = 1 - tessFade;
                 o.texcoord1 = v.texcoord1;
                 UNITY_TRANSFER_SHADOW(o,v.texcoord1.xy); // pass shadow coordinates to pixel shader
                 UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  

                 return o;
             }

             void displacement (inout TessVertex i)
             {
                  VertexOutput o = vert(i);
                  float3 viewDir = float3(0,0,1);

                  VirtualMapping mapping = GetMapping(o, _SplatControl, _SplatParams);
                  LayerParams mData = GetMainParams(o, mapping, _TexScales.xy);
                  SamplePerTex(_PropertyTex, mData, _PerTexScaleRange);

                  half3 extraData = float3(0,0,0);
                  #if _TRIPLANAR
                  extraData = o.extraData.xyz;
                  #endif

                  #if _TWOLAYER || _DETAILMAP
                  LayerParams sData = GetSecondParams(o, mapping, _TexScales.zw);
                  sData.layerBlend = mData.layerBlend;
                  SamplePerTex(_PropertyTex, sData, _PerTexScaleRange);
                  float second = SampleLayerHeight(mapping.weights, viewDir, sData, extraData.xyz, _TessData1.z, _TessData2.z);
                  #endif

                  float splats = SampleLayerHeight(mapping.weights, viewDir, mData, extraData.xyz, _TessData1.z, _TessData2.z);

                  #if _TWOLAYER
                     // blend layers together..
                     float hfac = HeightBlend(splats, second, sData.layerBlend, _TessData2.z);
                     splats = lerp(splats, second, hfac);
                  #endif

                  half upBias = _TessData2.w;
                  #if _PERTEXDISPLACEPARAMS
                  float3 upBias3 = mData.upBias;
                     #if _TWOLAYER
                        upBias3 = lerp(upBias3, sData.upBias, hfac);
                     #endif
                  upBias = upBias3.x * mapping.weights.x + upBias3.y * mapping.weights.y + upBias3.z * mapping.weights.z;
                  #endif

                  #if _PUDDLES || _PUDDLEFLOW || _PUDDLEREFRACT || _LAVA
                     #if _PUDDLESPUSHTERRAIN
                     splats = max(splats - mapping.param.a, 0);
                     #else
                     splats = max(splats, mapping.param.a);
                     #endif
                  #endif

                  #if _TESSCENTERBIAS
                  splats -= 0.5;
                  #endif

                  #if _SNOW
                  float3 worldNormal = UnityObjectToWorldNormal(i.normal);
                  float3 worldPos = mul(unity_ObjectToWorld, i.pos);
                  float snowHeightFade = saturate((worldPos.y - _SnowHeightRange.x) / max(_SnowHeightRange.y, 0.001));
                  splats += DoSnowDisplace(splats, i.coords.xy, worldNormal, snowHeightFade, mapping.param.a);
                  #endif

                  float3 offset = (lerp(i.normal, float3(0,1,0), upBias) * (i.camDist.w * _TessData1.y * splats));

                  #if _TESSDAMPENING
                  offset *= (mapping.c0.a * mapping.weights.x + mapping.c1.a * mapping.weights.y + mapping.c2.a * mapping.weights.z);
                  #endif

                  #if _CUSTOMUSERFUNCTION
                  CustomMegaSplatFunction_PostDisplacement(i.pos.xyz, offset, i.normal, i.tangent, i.coords.xy);
                  #else
                  i.pos.xyz += offset;
                  #endif


             }

             #if _TESSEDGE
             float4 Tessellation(TessVertex v, TessVertex v1, TessVertex v2)
             {
                 return UnityEdgeLengthBasedTess(v.pos, v1.pos, v2.pos, _TessData1.w);
             }
             #elif _TESSDISTANCE
             float4 Tessellation (TessVertex v0, TessVertex v1, TessVertex v2) 
             {
                return MegaSplatDistanceBasedTess( v0.camDist.w, v1.camDist.w, v2.camDist.w, _TessData1.x );
             }
             #endif

             OutputPatchConstant hullconst (InputPatch<TessVertex,3> v) {
                 OutputPatchConstant o = (OutputPatchConstant)0;
                 float4 ts = Tessellation( v[0], v[1], v[2] );
                 o.edge[0] = ts.x;
                 o.edge[1] = ts.y;
                 o.edge[2] = ts.z;
                 o.inside = ts.w;
                 return o;
             }
             [UNITY_domain("tri")]
             [UNITY_partitioning("fractional_odd")]
             [UNITY_outputtopology("triangle_cw")]
             [UNITY_patchconstantfunc("hullconst")]
             [UNITY_outputcontrolpoints(3)]
             TessVertex hull (InputPatch<TessVertex,3> v, uint id : SV_OutputControlPointID) 
             {
                 return v[id];
             }

             [UNITY_domain("tri")]
             VertexOutput domain (OutputPatchConstant tessFactors, const OutputPatch<TessVertex,3> vi, float3 bary : SV_DomainLocation) 
             {
                 TessVertex v = (TessVertex)0;
                 v.pos =         vi[0].pos * bary.x +       vi[1].pos * bary.y +       vi[2].pos * bary.z;
                 v.normal =         vi[0].normal * bary.x +       vi[1].normal * bary.y +       vi[2].normal * bary.z;
                 v.coords =         vi[0].coords * bary.x +       vi[1].coords * bary.y +       vi[2].coords * bary.z;
                 v.camDist =        vi[0].camDist * bary.x +      vi[1].camDist * bary.y +      vi[2].camDist * bary.z;
                 #if _TRIPLANAR
                 v.extraData =      vi[0].extraData * bary.x +    vi[1].extraData * bary.y +    vi[2].extraData * bary.z;
                 v.triplanarUVW =   vi[0].triplanarUVW * bary.x + vi[1].triplanarUVW * bary.y + vi[2].triplanarUVW * bary.z; 
                 #endif
                 v.tangent =        vi[0].tangent * bary.x +      vi[1].tangent * bary.y +      vi[2].tangent * bary.z;
                 v.macroUV =        vi[0].macroUV * bary.x +      vi[1].macroUV * bary.y +      vi[2].macroUV * bary.z;
                 v.posWorld =       vi[0].posWorld * bary.x +     vi[1].posWorld * bary.y +     vi[2].posWorld * bary.z;

                 #if !_PASSMETA && !_PASSSHADOWCASTER && !_PASSDEFERRED
                    #if FOG_LINEAR || FOG_EXP || FOG_EXP2
                       v.fogCoord = vi[0].fogCoord * bary.x + vi[1].fogCoord * bary.y + vi[2].fogCoord * bary.z;
                    #endif
                 #endif
                 v.ambientOrLightmapUV = vi[0].ambientOrLightmapUV * bary.x + vi[1].ambientOrLightmapUV * bary.y + vi[2].ambientOrLightmapUV * bary.z;
                 #if defined(SHADOWS_ENABLED)
                 v._ShadowCoord = vi[0]._ShadowCoord * bary.x + vi[1]._ShadowCoord * bary.y + vi[2]._ShadowCoord * bary.z;
                 #endif
                 v.texcoord1 = vi[0].texcoord1 * bary.x + vi[1].texcoord1 * bary.y + vi[2].texcoord1 * bary.z;
                 #if _TESSPHONG
                 float3 p = v.pos.xyz;

                 // Calculate deltas to project onto three tangent planes
                 float3 p0 = dot(vi[0].pos.xyz - p, vi[0].normal) * vi[0].normal;
                 float3 p1 = dot(vi[1].pos.xyz - p, vi[1].normal) * vi[1].normal;
                 float3 p2 = dot(vi[2].pos.xyz - p, vi[2].normal) * vi[2].normal;

                 // Lerp between projection vectors
                 float3 vecOffset = bary.x * p0 + bary.y * p1 + bary.z * p2;

                 // Add a fraction of the offset vector to the lerped position
                 p += 0.5 * vecOffset;

                 v.pos.xyz = p;
                 #endif

                 displacement(v);
                 VertexOutput o = vert(v);
                 return o;
             }
            #endif
            #endif



            void Splat(VertexOutput i, inout LightingTerms o, float3 viewDir, float3x3 tangentTransform)
            {
               VirtualMapping mapping = GetMapping(i, _SplatControl, _SplatParams);
               SplatInput si = ToSplatInput(i, mapping);
               si.viewDir = viewDir;
               #if _SNOWGLITTER || _PUDDLEGLITTER || _PERTEXGLITTER
               si.wsView = viewDir;
               #endif

               MegaSplatLayer macro = (MegaSplatLayer)0;
               #if _SNOW
               float snowHeightFade = saturate((i.posWorld.y - _SnowHeightRange.x) / max(_SnowHeightRange.y, 0.001));
               #endif

               #if _USEMACROTEXTURE || _ALPHALAYER
                  float2 muv = i.coords.xy;

                  #if _SECONDUV
                  muv = i.macroUV.xy;
                  #endif
                  macro = SampleMacro(muv);
                  #if _SNOW && _SNOWOVERMACRO

                  DoSnow(macro, muv, mul(tangentTransform, normalize(macro.Normal)), snowHeightFade, 0, _GlobalPorosityWetness.x, i.camDist.y);
                  #endif

                  #if _DISABLESPLATSINDISTANCE
                  if (i.camDist.x <= 0.0)
                  {
                     #if _CUSTOMUSERFUNCTION
                     CustomMegaSplatFunction_Final(si, macro);
                     #endif
                     o.Albedo = macro.Albedo;
                     o.Normal = macro.Normal;
                     o.Emission = macro.Emission;
                     #if !_RAMPLIGHTING
                     o.Smoothness = macro.Smoothness;
                     o.Metallic = macro.Metallic;
                     o.Occlusion = macro.Occlusion;
                     #endif
                     #if _ALPHA || _ALPHATEST
                     o.Alpha = macro.Alpha;
                     #endif

                     return;
                  }
                  #endif
               #endif

               #if _SNOW
               si.snowHeightFade = snowHeightFade;
               #endif

               MegaSplatLayer splats = DoSurf(si, macro, tangentTransform);

               #if _DEBUG_OUTPUT_ALBEDO
               o.Albedo = splats.Albedo;
               #elif _DEBUG_OUTPUT_HEIGHT
               o.Albedo = splats.Height.xxx * saturate(splats.Albedo+1);
               #elif _DEBUG_OUTPUT_NORMAL
               o.Albedo = splats.Normal * 0.5 + 0.5 * saturate(splats.Albedo+1);
               #elif _DEBUG_OUTPUT_SMOOTHNESS
               o.Albedo = splats.Smoothness.xxx * saturate(splats.Albedo+1);
               #elif _DEBUG_OUTPUT_METAL
               o.Albedo = splats.Metallic.xxx * saturate(splats.Albedo+1);
               #elif _DEBUG_OUTPUT_AO
               o.Albedo = splats.Occlusion.xxx * saturate(splats.Albedo+1);
               #elif _DEBUG_OUTPUT_EMISSION
               o.Albedo = splats.Emission * saturate(splats.Albedo+1);
               #elif _DEBUG_OUTPUT_SPLATDATA
               o.Albedo = DebugSplatOutput(si);
               #else
               o.Albedo = splats.Albedo;
               o.Normal = splats.Normal;
               o.Metallic = splats.Metallic;
               o.Smoothness = splats.Smoothness;
               o.Occlusion = splats.Occlusion;
               o.Emission = splats.Emission;
                  
               #endif

               #if _ALPHA || _ALPHATEST
                  o.Alpha = splats.Alpha;
               #endif
            }



            #if _PASSMETA
            half4 frag(VertexOutput i) : SV_Target 
            {
                i.normal = normalize(i.normal);
                float3 viewDirection = normalize(_WorldSpaceCameraPos.xyz - i.posWorld.xyz);
                float3 normalDirection = i.normal;
                UnityMetaInput o;
                UNITY_INITIALIZE_OUTPUT( UnityMetaInput, o );

                LightingTerms lt = (LightingTerms)0;

                float3x3 tangentTransform = (float3x3)0;
                #if _SNOW
                tangentTransform = float3x3( i.tangent, i.bitangent, i.normal);

                #endif

                Splat(i, lt, viewDirection, tangentTransform);

                o.Emission = lt.Emission;
                
                float3 diffColor = lt.Albedo;
                float specularMonochrome;
                float3 specColor;
                diffColor = DiffuseAndSpecularFromMetallic( diffColor, lt.Metallic, specColor, specularMonochrome );
                float roughness = 1.0 - lt.Smoothness;
                o.Albedo = diffColor + specColor * roughness * roughness * 0.5;
                return UnityMetaFragment( o );

            }
            #elif _PASSSHADOWCASTER
            half4 frag(VertexOutput i) : COLOR
            {
               SHADOW_CASTER_FRAGMENT(i)
            }
            #elif _PASSDEFERRED
            void frag(
                VertexOutput i,
                out half4 outDiffuse : SV_Target0,
                out half4 outSpecSmoothness : SV_Target1,
                out half4 outNormal : SV_Target2,
                out half4 outEmission : SV_Target3
                #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
                   , out half4 outShadowMask : SV_Target4
                #endif
                )
            {
                i.normal = normalize(i.normal);
                float3x3 tangentTransform = float3x3( i.tangent, i.bitangent, i.normal);
                float3 viewDirection = normalize(_WorldSpaceCameraPos.xyz - i.posWorld.xyz);

                LightingTerms o = (LightingTerms)0;
                Splat(i, o, viewDirection, tangentTransform);
                #if _ALPHATEST
                clip(o.Alpha-0.5);
                #endif
                o.Normal = normalize(mul( o.Normal, tangentTransform ));

                LightPBRDeferred(i, o, viewDirection, 
                  outDiffuse, outSpecSmoothness, outNormal, outEmission
                  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
                  , outShadowMask
                  #endif
                  );
                



            }
            #else
            half4 frag(VertexOutput i) : COLOR 
            {

                i.normal = normalize(i.normal);

                float3x3 tangentTransform = float3x3( i.tangent, i.bitangent, i.normal);

                float3 viewDirection = normalize(_WorldSpaceCameraPos.xyz - i.posWorld.xyz);

                LightingTerms o = (LightingTerms)0;

                Splat(i, o, viewDirection, tangentTransform);

                #if _ALPHATEST
                clip(o.Alpha-0.5);
                #endif

                #if _DEBUG_OUTPUT_ALBEDO || _DEBUG_OUTPUT_HEIGHT || _DEBUG_OUTPUT_NORMAL || _DEBUG_OUTPUT_SMOOTHNESS || _DEBUG_OUTPUT_METAL || _DEBUG_OUTPUT_AO || _DEBUG_OUTPUT_EMISSION
                   return half4(o.Albedo,1);
                #else
                   o.Normal = normalize(mul( o.Normal, tangentTransform ));
                   half4 lit = LightPBR(i, o, viewDirection, i.ambientOrLightmapUV);
                   #if _ALPHA || _ALPHATEST
                   lit.a = o.Alpha;
                   #endif
                   return lit;
                #endif

            }
            #endif


            #if _LOWPOLY
            [maxvertexcount(3)]
            void geom(triangle VertexOutput input[3], inout TriangleStream<VertexOutput> s)
            {
               VertexOutput v0 = input[0];
               VertexOutput v1 = input[1];
               VertexOutput v2 = input[2];

               float3 norm = input[0].normal + input[1].normal + input[2].normal;
               norm /= 3;
               float3 tangent = input[0].tangent + input[1].tangent + input[2].tangent;
               tangent /= 3;
              
               float3 bitangent = input[0].bitangent + input[1].bitangent + input[2].bitangent;
               bitangent /= 3;

               #if _LOWPOLYADJUST
               v0.normal = lerp(v0.normal, norm, _EdgeHardness);
               v1.normal = lerp(v1.normal, norm, _EdgeHardness);
               v2.normal = lerp(v2.normal, norm, _EdgeHardness);
              
               v0.tangent = lerp(v0.tangent, tangent, _EdgeHardness);
               v1.tangent = lerp(v1.tangent, tangent, _EdgeHardness);
               v2.tangent = lerp(v2.tangent, tangent, _EdgeHardness);
              
               v0.bitangent = lerp(v0.bitangent, bitangent, _EdgeHardness);;
               v1.bitangent = lerp(v1.bitangent, bitangent, _EdgeHardness);;
               v2.bitangent = lerp(v2.bitangent, bitangent, _EdgeHardness);;
               #else
               v0.normal = norm;
               v1.normal = norm;
               v2.normal = norm;
              
               v0.tangent = tangent;
               v1.tangent = tangent;
               v2.tangent = tangent;
              
               v0.bitangent = bitangent;
               v1.bitangent = bitangent;
               v2.bitangent = bitangent;
               #endif


               s.Append(v0);
               s.Append(v1);
               s.Append(v2);
            }
            #endif
            ENDCG
        }
