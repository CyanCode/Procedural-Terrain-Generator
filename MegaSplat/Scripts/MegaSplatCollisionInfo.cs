//////////////////////////////////////////////////////
// MegaSplat - 256 texture splat mapping
// Copyright (c) Jason Booth, slipster216@gmail.com
//////////////////////////////////////////////////////

using UnityEngine;
using System.Collections;
using JBooth.VertexPainterPro;
using System.Collections.Generic;


// Add to an object or terrain and use it to querry which surface your colliding with, given a raycast hit. 
// To output the MegaSplatTextureList, turn on exportTextureList on your megasplat config. Then assign it
// in this component and call GetTextureName(hit) to get the texture you're colliding with
// You can also use this to querry for the displacement offset to simulate physics over a tessellated surface. 
// For this you will need to generate physics textures in the main diffuse array.
// Currently requires that mesh be read/write on the CPU. 

public class MegaSplatCollisionInfo : MonoBehaviour 
{
   [Tooltip("List of textures generated by the TextureArrayConfig")]
   public MegaSplatTextureList textureList;
   [Tooltip("Is this expected to be used with a two layer shader?")]
   public bool twoLayer = false;

   // cached physics info
   VertexInstanceStream stream;

   [System.Serializable]
   public class CachedData
   {
      public int[]     triangles;
      public Color[]   cachedColors;
      public List<Vector4> cachedUV3 = new List<Vector4>();
   }

   // When working, data is live on the CPU. But for static batching, or lightmapping, we might need to not have the Mesh Read/Write
   // anymore. If so, we need to cache this data and serialize it rather than fetching it from the mesh/steam. This gives us optimal
   // memory in both cases.

   [System.NonSerialized]
   public CachedData liveCache = new CachedData();
   [HideInInspector]
   public CachedData serializedCache;

   // for terrains
   Texture2D splatTexture;
   Texture2D paramTexture;
   Terrain terrain;
   // uv scales so we can get UV coordinates
   Vector4 uvScales = Vector2.one;
   float contrast = 0.5f;
   float displacement = 1;
   float upBias = 0;
   bool centered = true;
   bool puddles = false;
   Texture2D perTexProperties;

   public void BakeForSerialize()
   {
      Cache();
      serializedCache = new CachedData();
      serializedCache.cachedColors = liveCache.cachedColors;
      serializedCache.cachedUV3 = liveCache.cachedUV3;
      serializedCache.triangles = liveCache.triangles;
   }

   void Extract(Material mat)
   {
      if (mat.HasProperty("_TexScales"))
      {
         uvScales = mat.GetVector("_TexScales");
      }
      if (mat.HasProperty("_TessData1"))
      {
         displacement = mat.GetVector("_TessData1").y;
      }
      if (mat.HasProperty("_TessData2"))
      {
         Vector4 tessData2 = mat.GetVector("_TessData2");
         upBias = tessData2.w;
         contrast = tessData2.z;
         if (contrast >= 1)
            contrast = 0.999f;
         else if (contrast <= 0)
            contrast = 0.0001f;
      }
      if (mat.HasProperty("_PropertyTex") && mat.IsKeywordEnabled("_PERTEXDISPLACEPARAMS"))
      {
         perTexProperties = mat.GetTexture("_PropertyTex") as Texture2D;
      }
      centered = (mat.IsKeywordEnabled("_TESSCENTERBIAS"));
      puddles = (mat.IsKeywordEnabled("_PUDDLES") || mat.IsKeywordEnabled("_PUDDLEFLOW") || mat.IsKeywordEnabled("_PUDDLEREFRACTION") || mat.IsKeywordEnabled("_LAVA"));

   }

   void Start()
   {
      Cache();
   }

	void Cache() 
   {
      terrain = GetComponent<Terrain>();
      if (terrain != null)
      {
         var mat = terrain.materialTemplate;
         if (mat != null)
         {
            if (mat.HasProperty("_SplatControl"))
            {
               splatTexture = mat.GetTexture("_SplatControl") as Texture2D;
               Extract(mat);
            }
            else
            {
               Debug.LogWarning("Terrain without MegaSplat shader has a MegaSplatCollisionInfo");
            }
            if (puddles && mat.HasProperty("_SplatParams"))
            {
               paramTexture = mat.GetTexture("_SplatParams") as Texture2D;
            }
         }
      }
      else
      {
         
         stream = GetComponent<VertexInstanceStream>();
         var mf = GetComponent<MeshFilter>();
         var mr = GetComponent<MeshRenderer>();

         if (mf.sharedMesh.isReadable)
         {
            serializedCache = null;
            if (mf.sharedMesh != null)
            {
               Mesh mesh = mf.sharedMesh;
               liveCache.triangles = mesh.triangles;
               if (stream == null)
               {
                  liveCache.cachedColors = mesh.colors;
                  mesh.GetUVs(3, liveCache.cachedUV3);
               }
               else
               {
                  liveCache.cachedColors = stream.colors;
                  liveCache.cachedUV3 = stream.uv3;
               }
            }
         }
         else if (serializedCache != null)
         {
            liveCache.triangles = serializedCache.triangles;
            liveCache.cachedColors = serializedCache.cachedColors;
            liveCache.cachedUV3 = serializedCache.cachedUV3;
         }

         if (mr != null)
         {
            var mat = mr.sharedMaterial;
            Extract(mat);
         }
      }
	}
      
   public static Vector3 LocalPointToTerrain(Terrain ter, Vector3 point, Texture2D splatControl)
   {
      float x = (point.x / ter.terrainData.size.x) * splatControl.width;
      float z = (point.z / ter.terrainData.size.z) * splatControl.height;
      float y = ter.terrainData.GetHeight((int)x, (int)z);
      return new Vector3(x, y, z);
   }

   struct HitData
   {
      public int index0;
      public int index1;
      public float weight;
      public float puddleLevel;
   }

   HitData GetHit(RaycastHit hit)
   {
      HitData o = new HitData();
      if (splatTexture != null && terrain != null)
      {
         Vector3 pnt = hit.point;
         pnt = transform.worldToLocalMatrix.MultiplyPoint(pnt);
         pnt = LocalPointToTerrain(terrain, pnt, splatTexture);
         Color c = splatTexture.GetPixel((int)pnt.x, (int)pnt.z);
         o.index0 = Mathf.RoundToInt(c.r * 255);
         o.index1 = Mathf.RoundToInt(c.g * 255);
         o.weight = c.b;

         if (puddles && paramTexture != null)
         {
            Color c2 = paramTexture.GetPixel((int)pnt.x, (int)pnt.z);
            o.puddleLevel = c2.a;
         }
      }
      else
      {
         int tidx = hit.triangleIndex;
         if (tidx >= 0 && tidx < liveCache.triangles.Length)
         {
            int i0 = liveCache.triangles[tidx * 3];
            int i1 = liveCache.triangles[tidx * 3 + 1];
            int i2 = liveCache.triangles[tidx * 3 + 2];


            int ccount = liveCache.cachedColors.Length;
            if (i0 > ccount || i1 > ccount || i2 > ccount)
            {
               Debug.LogWarning("index out of range on " + gameObject.name);
               return o;
            }

            // get closest index with barycentric coordinates
            Vector3 bary = hit.barycentricCoordinate;

            int bestIndex = i0;
            if (bary.y > bary.x && bary.z > bary.x)
            {
               bestIndex = i1;
            }
            if (bary.z > bary.y && bary.z > bary.y)
            {
               bestIndex = i2;
            }

            Color c = liveCache.cachedColors[bestIndex];

            o.index0 = Mathf.RoundToInt(c.a * 255);
            o.index1 = 0;
            o.weight = 0;
            if ((twoLayer || puddles) && liveCache.cachedUV3.Count == ccount)
            {
               Vector4 v = liveCache.cachedUV3[bestIndex];
               o.index1 = Mathf.RoundToInt(v.w * 255);
               o.weight = v.x;
               o.puddleLevel = v.z;
            }
         }
      }
      return o;
   }

   float SampleLayerHeight(Vector2 uv, int i0, int i1, int i2, Vector3 bary)
   {
      uv.x -= (int)uv.x;
      uv.y -= (int)uv.y;

      Texture2D t0 = textureList.physicsTex[i0];
      Texture2D t1 = textureList.physicsTex[i1];
      Texture2D t2 = textureList.physicsTex[i2];
      Color tc0 = t0.GetPixelBilinear(uv.x, uv.y);
      Color tc1 = t1.GetPixelBilinear(uv.x, uv.y);
      Color tc2 = t2.GetPixelBilinear(uv.x, uv.y);

      Vector3 bWeights = ComputeWeights(bary, tc0.a, tc1.a, tc2.a, contrast);

      return tc0.a * bWeights.x + tc1.a * bWeights.y + tc2.a * bWeights.z;
   }

   float HeightBlend(float h1, float h2, float slope, float contrast)
   {
      h2 = 1.0f - h2;
      float h3 = h1 - h2;
      if (h3 < 0)
         h3 *= -1;
      float min = h1;
      if (h2 < h1)
         min = h2;
      float tween = Mathf.Clamp01((slope - min) / Mathf.Max(h3, 0.001f)); 
      float r =  Mathf.Clamp01( ( tween - (1.0f-contrast) ) / contrast);
      return r;
   }

   Color SamplePerTex(int i0, int i1, int i2, Vector3 bary)
   {
      if (perTexProperties == null)
         return new Color(1, 0, 1, 0);
      Color c0 = perTexProperties.GetPixel(i0, 2);
      Color c1 = perTexProperties.GetPixel(i1, 2);
      Color c2 = perTexProperties.GetPixel(i2, 2);
      return c0 * bary.x + c1 * bary.y + c2 * bary.z;
   }
      

   Vector3 ComputeWeights(Vector3 iWeights, float tex0, float tex1, float tex2, float contrast)
   {
      // compute weight with height map
      const float epsilon = 1.0f / 1024.0f;
      Vector3 weights = new Vector3(iWeights.x * (tex0 + epsilon), 
         iWeights.y * (tex1 + epsilon),
         iWeights.z * (tex2 + epsilon));

      // Contrast weights
      float maxWeight = weights.x;
      if (weights.y > maxWeight)
         maxWeight = weights.y;
      if (weights.z > maxWeight)
         maxWeight = weights.z;
      
      float transition = contrast * maxWeight;
      float threshold = maxWeight - transition;
      float scale = 1.0f / transition;

      weights.x = Mathf.Clamp01((weights.x-threshold) * scale);
      weights.y = Mathf.Clamp01((weights.y-threshold) * scale);
      weights.z = Mathf.Clamp01((weights.z-threshold) * scale);
      // Normalize weights.
      float weightScale = 1.0f / (weights.x + weights.y + weights.z);
      weights *= weightScale;
      return weights;
   }

   Vector3 Barycentric(Vector2 p, Vector2 a, Vector2 b, Vector2 c)
   {
      Vector2 v0 = b - a;
      Vector2 v1 = c - a;
      Vector2 v2 = p - a;
      float d00 = Vector2.Dot(v0, v0);
      float d01 = Vector2.Dot(v0, v1);
      float d11 = Vector2.Dot(v1, v1);
      float d20 = Vector2.Dot(v2, v0);
      float d21 = Vector2.Dot(v2, v1);
      float denom = d00 * d11 - d01 * d01;
      float v = (d11 * d20 - d01 * d21) / denom;
      float w = (d00 * d21 - d01 * d20) / denom;
      float u = 1.0f - v - w;
      return new Vector3(u, v, w);
   }

   /// <summary>
   /// Given a raycast hit, get the new position after tessellation
   /// </summary>
   /// <returns>The physics offset position.</returns>
   /// <param name="hit">Hit.</param>
   public Vector3 GetPhysicsOffsetPosition(RaycastHit hit)
   {
      if (textureList.physicsTex != null && textureList.physicsTex.Length > 0)
      {
         if (splatTexture != null && terrain != null)
         {
            Vector3 pnt = hit.point;
            pnt = transform.worldToLocalMatrix.MultiplyPoint(pnt);
            pnt = LocalPointToTerrain(terrain, pnt, splatTexture);
            int floorX = (int)pnt.x;
            int floorY = (int)pnt.z;
            Vector2 suv = new Vector2(pnt.x - floorX, pnt.z - floorY);
            Color c0 = splatTexture.GetPixel(floorX, floorY);
            Color c1;
            Color c2;

            Vector2 uv0 = new Vector2(floorX, floorY);
            Vector2 uv1 = new Vector2(floorX + 1, floorY);
            Vector2 uv2 = new Vector2(floorX + 1, floorY + 1);

            if (suv.x < suv.y)
            {
               uv1 = new Vector2(floorX, floorY + 1);
            }
            c0 = splatTexture.GetPixel((int)uv0.x, (int)uv0.y);
            c1 = splatTexture.GetPixel((int)uv1.x, (int)uv1.y);
            c2 = splatTexture.GetPixel((int)uv2.x, (int)uv2.y);

            var bary = Barycentric(new Vector2(pnt.x, pnt.z), uv0, uv1, uv2);
            Vector2 uv = hit.textureCoord;

            float bias = upBias;
            int i0 = Mathf.RoundToInt(c0.r * 255);
            int i1 = Mathf.RoundToInt(c1.r * 255);
            int i2 = Mathf.RoundToInt(c2.r * 255);



            Color pt0 = SamplePerTex(i0, i1, i2, bary);
            Vector2 uvScaled0 = uv;
            uvScaled0.x *= uvScales.x;
            uvScaled0.y *= uvScales.y;
            float height0 = SampleLayerHeight(uvScaled0, i0, i1, i2, bary);
            float height1 = 0;
            float offset = height0;
            if (twoLayer)
            {
               int i3 = Mathf.RoundToInt(c0.g * 255);
               int i4 = Mathf.RoundToInt(c1.g * 255);
               int i5 = Mathf.RoundToInt(c2.g * 255);
               Vector2 uvScaled1 = uv;
               uvScaled1.x *= uvScales.z;
               uvScaled1.y *= uvScales.w;
               height1 = SampleLayerHeight(uvScaled1, i3, i4, i5, bary);
               float weight = c0.b * bary.x + c1.b * bary.y + c2.b * bary.z;
               float hl = HeightBlend(height0, height1, weight, contrast);
               offset = Mathf.Lerp(height0, height1, hl);

               pt0 = Color.Lerp(pt0, SamplePerTex(i3, i4, i5, bary), hl);
            }

            if (perTexProperties != null)
               bias = pt0.a;

            if (centered)
            {
               offset -= 0.5f;
            }
            offset *= displacement * pt0.b;

            Vector3 normal = terrain.terrainData.GetInterpolatedNormal(suv.x, suv.y);
            Vector3 biasVec = Vector3.Lerp(normal, Vector3.up, bias);
            return hit.point + (biasVec * offset);
         }
         else if (liveCache.triangles != null) // mesh
         {
            int tidx = hit.triangleIndex;
            if (tidx >= 0 && tidx < liveCache.triangles.Length)
            {
               int t0 = liveCache.triangles[tidx * 3];
               int t1 = liveCache.triangles[tidx * 3 + 1];
               int t2 = liveCache.triangles[tidx * 3 + 2];

               int ccount = liveCache.cachedColors.Length;
               if (t0 > ccount || t1 > ccount || t2 > ccount)
               {
                  Debug.LogWarning("index out of range on " + gameObject.name);
                  return Vector3.zero;
               }

               Vector3 bary = hit.barycentricCoordinate;
               // get heights at each location and bary together..
               Color c0 = liveCache.cachedColors[t0];
               Color c1 = liveCache.cachedColors[t1];
               Color c2 = liveCache.cachedColors[t2];
               Vector2 uv = hit.textureCoord;

               int i0 = Mathf.RoundToInt(c0.a * 255);
               int i1 = Mathf.RoundToInt(c1.a * 255);
               int i2 = Mathf.RoundToInt(c2.a * 255);



           
               Color pt0 = SamplePerTex(i0, i1, i2, bary);

               Vector2 uvScaled0 = uv;
               uvScaled0.x *= uvScales.x;
               uvScaled0.y *= uvScales.y;

               float height0 = SampleLayerHeight(uvScaled0, i0, i1, i2, bary);
               float height1 = 0;
               float weight = 0;

               float bias = upBias;
               float offset = height0;
               float puddleOffset = 0;
               if (puddles && liveCache.cachedUV3 != null && liveCache.cachedUV3.Count == ccount)
               {
                  puddleOffset = liveCache.cachedUV3[i0].y * bary.x + liveCache.cachedUV3[i1].y * bary.y + liveCache.cachedUV3[i2].y * bary.z;
               }

               if (twoLayer && liveCache.cachedUV3.Count == ccount)
               {
                  Vector4 v0 = liveCache.cachedUV3[t0];
                  Vector4 v1 = liveCache.cachedUV3[t1];
                  Vector4 v2 = liveCache.cachedUV3[t2];
                  int i3 = Mathf.RoundToInt(v0.w * 255);
                  int i4 = Mathf.RoundToInt(v1.w * 255);
                  int i5 = Mathf.RoundToInt(v2.w * 255);
                  Vector2 uvScaled1 = uv;
                  uvScaled1.x *= uvScales.z;
                  uvScaled1.y *= uvScales.w;
                  height1 = SampleLayerHeight(uvScaled1, i3, i4, i5, bary);
                  weight = v0.x * bary.x + v1.x * bary.y + v2.x * bary.z;
                  float hl = HeightBlend(height0, height1, weight, contrast);
                  offset = Mathf.Lerp(height0, height1, hl);
                  pt0 = Color.Lerp(pt0, SamplePerTex(i3, i4, i5, bary), hl);
                  if (puddles)
                  {
                     float puddleOffset2 = liveCache.cachedUV3[i3].y * bary.x + liveCache.cachedUV3[i4].y * bary.y + liveCache.cachedUV3[i5].y * bary.z;
                     puddleOffset = Mathf.Lerp(puddleOffset, puddleOffset2, hl);
                  }
               }

               if (puddles)
               {
                  offset -= puddleOffset;
                  if (offset < 0)
                     offset = 0;
               }
               if (centered)
               {
                  offset -= 0.5f;
               }
               offset *= displacement * pt0.b;


               if (perTexProperties != null)
               {
                  bias = pt0.a;
               }
               float perVertDisplacementBias = 1;
               if (liveCache.cachedUV3.Count == liveCache.triangles.Length)
               {
                  perVertDisplacementBias = 1.0f - Mathf.Clamp01(liveCache.cachedUV3[t0].z * bary.x + liveCache.cachedUV3[t1].z * bary.y + liveCache.cachedUV3[t2].z * bary.z);
               }
               // note, this is inaccurate compared to the actual interpolated normal..
               Vector3 biasVec = Vector3.Lerp(hit.normal, Vector3.up, bias);
               return hit.point + (biasVec * offset * perVertDisplacementBias);
               
            }
         }
      }
      return hit.point;
   }


   /// <summary>
   /// Given a raycats hit, get the name of the texture it's collided with
   /// </summary>
   /// <returns>The texture name.</returns>
   /// <param name="hit">Hit.</param>
   public string GetTextureName(RaycastHit hit)
   {
      if (textureList == null || textureList.textureNames == null || textureList.textureNames.Length < 0)
      {
         Debug.LogWarning("Texture list not set on MegaSplatCollisionInfo " + gameObject.name);
         return null;
      }

      HitData d = GetHit(hit);

      if (puddles && d.puddleLevel > 0.4f)
      {
         return "Puddles";
      }

      if (twoLayer)
      {
         if (d.weight > 0.5f)
         {
            int textureIndex2 = Mathf.Clamp(d.index1, 0, textureList.textureNames.Length - 1);
            return textureList.textureNames[textureIndex2];
         }
      }

      int textureIndex = Mathf.Clamp(d.index0, 0, textureList.textureNames.Length - 1);
      return textureList.textureNames[textureIndex];

   }
}
